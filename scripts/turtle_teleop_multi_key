#!/usr/bin/env python
#linear drive(translation)

from __future__ import print_function

# import tf
import rospy
import math
import sys, select, os, time

from math import cos, sin, degrees, sqrt

from nav_msgs.msg import Odometry
from std_msgs.msg import String
from geometry_msgs.msg import Point, Pose, Quaternion, Twist, Vector3
from tf.transformations import euler_from_quaternion

def to_positive_angle(th):
    while True:
        if th < 0:
            th += 360
        if th > 0:
            ans = th % 360
            return ans
            break

def Distance2D(pos_x, pos_y):
    dist = sqrt((pos_x**2)+(pos_y**2))
    return dist
#
# def pub_cmdv(): # Write turtlebot velocity
#      = rospy.Publisher('/counter', Twist, queue_size=3)

def pub_odom():
    pub_odom = rospy.Publisher('cmd_vel',Twist, queue_size=3)

def sub_odom():
    odom = rospy.Subscriber('/odom',Odometry, callback_odom)

def sub_chat():
    chat =  rospy.Subscriber('chatter', String, callback_chat)

def callback_init_odom(data):
    global init_odom_x, init_odom_y
    init_odom_x = data.pose.pose.position.x
    init_odom_y = data.pose.pose.position.y

def callback_odom(data):
    global odom_x, odom_y, odom_z
    odom_x = data.pose.pose.position.x
    odom_y = data.pose.pose.position.y

    q1 = data.pose.pose.orientation.x
    q2 = data.pose.pose.orientation.y
    q3 = data.pose.pose.orientation.z
    q4 = data.pose.pose.orientation.w
    q = (q1, q2, q3, q4)

    e = euler_from_quaternion(q)

    odom_z = degrees(e[2])
    odom_z = to_positive_angle(odom_z)

def callback_chat(data):
    global opt_x, opt_y, opt_dist, opt_dist2
    opt = data.data.split("|")
    opt_x = float(int(opt[1])*0.01)#float(opt[1])
    opt_y = float(int(opt[2])*0.01)#float(opt[2])
    opt_dist = float(opt[4])*0.01#float(opt[4])

    # print(opt)
    # print("[OPT] X : {:3d} Y : {:3d} D : {:3f}".format(opt_x, opt_y, opt_dist))

#  git clone https://github.com/ROBOTIS-GIT/turtlebot3.git
#  several problems Solving process.

dist = 0
cur_x, cur_y = (0.0, 0.0)
opt_x, opt_y, opt_dist = (0.1, 0.1, 0.1)
odom_x, odom_y, odom_z, odom_dist = (0.1, 0.1, 0.1, 0)
gap_x, gap_y, gap_z = (0, 0, 0)
local_x, local_y, local_z = (0, 0, 0)

if __name__=="__main__":
    rospy.init_node('turtlebot3_teleop', anonymous=True)
    rate = rospy.Rate(10)

    currentTime = rospy.Time.now()
    lastTime = rospy.Time.now()

    pub_odom()
    sub_odom()
    sub_chat()

    # rospy.Subscriber('/odom',Odometry, callback_init_odom)

    twist = Twist()
    twist.linear.x = 0.0; twist.linear.y = 0.0; twist.linear.z = 0.0
    twist.angular.x = 0.0; twist.angular.y = 0.0; twist.angular.z = 0.0
    pub_odom.publish(twist)
    # current twist value


    while not rospy.is_shutdown():
        currentTime = rospy.Time.now()

        odom_x -= init_odom_x
        odom_y -= init_odom_y

        local_x = float(opt_x + cos(opt_y) * dist)
        local_y = float(opt_x + sin(opt_y) * dist)
        local_z = float(opt_y + dist / 0.093)

        gap_x = float((odom_x - local_x)/odom_x)*100
        gap_y = float((odom_y - local_y)/odom_y)*100
        gap_z = float((odom_z - local_z)/odom_z)*100

        odom_dist = Distance2D(odom_x, odom_y)

        print("-----------------------------------------------")
        print("OPT|| X : {:3f} Y : {:3f} dist : {:3f}".format(opt_x, opt_y, opt_dist))
        print("ODM|| X : {:3f} Y : {:3f} Z : {:3f} dist : {:3f}".format(odom_x, odom_y, odom_z, odom_dist))
        print("LCL|| X : {:3f} Y : {:3f} Z : {:3f}".format(local_x, local_y, local_z))
        print("GAP|| X : {:3f}% Y : {:3f}% Z : {:3f}%".format(gap_x, gap_y, gap_z))

        dist = (currentTime - lastTime).to_sec()
        lastTime = rospy.Time.now()
        rate.sleep()
